# 对象实例化

下面的例子展示如何访问实例变量和调用成员方法：

```java
public class Puppy{
   int puppyAge;
   public Puppy(String name){
      // 这个构造器仅有一个参数：name
      System.out.println("小狗的名字是 : " + name );
   }

   public void setAge( int age ){
       puppyAge = age;
   }

   public int getAge( ){
       System.out.println("小狗的年龄为 : " + puppyAge );
       return puppyAge;
   }

   public static void main(String[] args){
      /* 创建对象 */
      Puppy myPuppy = new Puppy( "tommy" );
      /* 通过方法来设定age */
      myPuppy.setAge( 2 );
      /* 调用另一个方法获取age */
      myPuppy.getAge( );
      /*你也可以像下面这样访问成员变量 */
      System.out.println("变量值 : " + myPuppy.puppyAge );
   }
}
```

# 构造方法

每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。下面是一个构造方法示例：

```java
public class Puppy {

  public Puppy() {}

  public Puppy(String name) {
    // 这个构造器仅有一个参数：name
  }
}
```

构造方法的名字和类名相同，并且没有返回值，构造方法主要用于为类的对象定义初始化状态。我们不能直接调用构造方法，必须通过 new 关键字来自动调用，从而创建类的实例。Java 的类都要求有构造方法，如果没有定义构造方法，Java 编译器会为我们提供一个缺省的构造方法，也就是不带参数的构造方法。

使用 Java 类实例化一个对象的时候，如果在类中不显式的声明其构造函数，则会使用一个默认的构造函数来初始化对象。

```java
//一个没有显式声明构造函数的类
Public class People{
    int age = 23;
    Public void getAge(){
        System.out.print("the age is "+age);
    }
}

//用这个类来实例化一个对象
People xiaoMing = new People(); // People() 是People类的默认构造函数，它什么也不干
xiaoMing.getAge();//打印年龄
```

也可以在声明类的时候显式的声明一个构造函数：

```java
//一个带显式构造函数的类
Public class People{
    int age = 23;
        Public void getAge(){
        System.out.print("the age is "+ age);
    }
    // 显式声明一个带参数的构造函数，用于初始化年龄
    Public People(int a){
        this.age = a;
    }
}

//用这个类来实例化一个对象
People xiaoMing = new People(20); // 使用带参数的构造函数来实例化对象
xiaoMing.getAge(); // 打印出来的年龄变为20
```

## 交叉调用

Java 允许在某个构造函数中调用另一个构造函数，推荐的模式是从最小的构造器一直调用到最大的构造器，示例代码如下：

```java
public class Cons {

  public Cons() {
    // A no arguments constructor that sends default values to the largest
    this(madeUpArg1Value, madeUpArg2Value, madeUpArg3Value);
  }

  public Cons(int arg1, int arg2) {
    // An example of a partial constructor that uses the passed in arguments
    // and sends a hidden default value to the largest
    this(arg1, arg2, madeUpArg3Value);
  }

  // Largest constructor that does the work
  public Cons(int arg1, int arg2, int arg3) {
    this.arg1 = arg1;
    this.arg2 = arg2;
    this.arg3 = arg3;
  }
}
```

这里需要注意的是，一定要把 super 或者对于其他构造函数的调用语句放在本构造函数的第一行。另一种可以替代的方式就是封装成单独的 set 方法：

```java
public class Cons {
  public static Cons newCons(int arg1,...) {
    // This function is commonly called valueOf, like Integer.valueOf(..)
    // More recently called "of", like EnumSet.of(..)Cons c = new Cons(...);
    c.setArg1(....);return c;
  }
}
```

# 构造函数顺序

Java 虚拟机通过装载、连接、初始化来使得一个 Java 类型可以被 Java 程序所使用，如下图所示，其中连接过程又分为验证、准备、解析三个部分。其中部分类的解析过程可以推迟到程序真正使用其某个符号引用时再去解析。

## 静态初始化

主动使用会导致类的初始化，其超类均将在该类的初始化之前被初始化，但通过子类访问父类的静态字段或方法时，对于子类(或子接口、接口的实现类)来说，这种访问就是被动访问，或者说访问了该类(接口)中的不在该类(接口)中声明的静态成员。

- 无论直接通过 new 创建出来的，还是通过反射、克隆、序列化创建的)创建某个类新的实例
- 使用某个类的静态方法
- 访问某个类或接口的静态字段
- 调用 JavaAPI 中的某些反射方法
- 初始化某个类的子类(要求其祖先类都要被初始化，否则无法正确访问其继承的成员)
- 启动某个标明为启动类的类(含有 main()方法)

下面我们用例子来阐述下类初始化的流程:

```java
public class GrandPa {

  static {
    System.out.println("祖父静态初始化");
  }
}

public class Parent extends GrandPa {
  static String language = "Chinese";

  static {
    System.out.println("父类静态初始化");
  }

  {
    System.out.println("父类实例初始化");
  }

  Parent() {
    System.out.println("父类构造函数");
  }
}

public class Child extends Parent {

  static {
    System.out.println("子类静态初始化");
  }

  {
    System.out.println("子类实例初始化");
  }

  Child() {
    System.out.println("子类构造函数");
  }

  public static void main(String args[]) {
    Child child = new Child();
  }
}

public class PassiveAccessTest {

  public static void main(String[] args) {
    System.out.println(Child.language);
  }
}
//输出结果
/*

祖父静态初始化
父类静态初始化
Chinese
*/
```

而如果我们在`Child`类中访问本类继承自父类的静态变量，会得到如下顺序:

```
祖父静态初始化
父类静态初始化
子类静态初始化
Chinese
```

## 实例初始化

类的初始化会从祖先类到子类、按出现顺序，对类变量的初始化语句、静态初始化语句块依次进行初始化。而对类实例的初始化也类似，会从祖先类到子类、按出现顺序，对类成员的初始化语句、实例初始化块、构造方法依次进行初始化。

当我们在子类中初始化子类时，即:

```java
public static void main(String args[]) {

    Child child = new Child();

}
```

其输出效果为:

```
祖父静态初始化
父类静态初始化
子类静态初始化
父类实例初始化
父类构造函数
子类实例初始化
子类构造函数
```

而如果我们为 `Child` 添加如下属性:

```java
static Child child = new Child();
```

那么此时实例构造过程会被提前到静态初始化之前，其输出为:

```java
祖父静态初始化
父类静态初始化
父类实例初始化 // 此时父类实例初始化在子类静态初始化之前了
父类构造函数
子类实例初始化
子类构造函数
子类静态初始化
父类实例初始化
父类构造函数
子类实例初始化
子类构造函数
```

下面看一个复杂点的例子:

```java
class ComplexInitialization implements Cloneable {
  public static int k = 0;
  public static ComplexInitialization t1 = new ComplexInitialization("t1");
  public static ComplexInitialization t2 = new ComplexInitialization("t2");
  public static int i = print("i");
  public static int n = 99;

  public int j = print("j");

  {
    print("构造块");
  }

  static {
    print("静态块");
  }

  public ComplexInitialization(String str) {
    System.out.println((++k) + ":" + str + "    i=" + i + "  n=" + n);
    ++n;
    ++i;
  }

  public static int print(String str) {
    System.out.println((++k) + ":" + str + "   i=" + i + "   n=" + n);
    ++n;
    return ++i;
  }

  public static void main(String[] args) {
    ComplexInitialization t = new ComplexInitialization("init");
  }
}
```

其输出为:

```s
首先T类被加载、连接后进行初始化，会先对字段k、t1、t2、i、n以及static块进行初始化。
1:j   i=0   n=0

t1实例的初始化会初始化实例成员j，(实际上先进行父类实例内容的初始化)先调用静态方法print，并执行实例初始化块{}，输出
2:构造块   i=1   n=1

随后调用t1实例的构造函数，输出:
3:t1    i=2  n=2

类似有t2实例的初始化:
4:j   i=3   n=3

构造块 i=4 n=4
5:构造块   i=4   n=4
6:t2    i=5  n=5

i的初始化:
7:i   i=6   n=6

n的初始化和静态块的初始化:
8:静态块   i=7   n=99

t实例的初始化:
9:j   i=8   n=100
10:构造块   i=9   n=101
11:init    i=10  n=102
```
