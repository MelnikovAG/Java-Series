# Java 中的死锁案例

# Thread Saturation Deadlock | 线程饥饿死锁

在线程池中任务如果依赖其他任务的执行，那么就可能出现死锁。对于单 worker 线程的 Executor，如果在一个已经被提交的任务中提交另一个任务到 Executor 中就会发生死锁。

```java
class Task implements Runnable {
  private final ExecutorService executorService;

  public Task(ExecutorService executors) {
    this.executorService = executors;
  }

  @Override
  public void run() {
    System.out.println("Thread enter: " + Thread.currentThread().getName());
    Task2 task2 = new Task2();

    // 在任务中嵌套执行任务,由于线程池大小只有1,所以该线程永远不会被执行,而正在执行的线程也一直无法返回,这就照成了saturation deadlock
    Future<Boolean> future = executorService.submit(task2);
    try {
      Boolean aBoolean = future.get();
    } catch (InterruptedException e) {
      e.printStackTrace();
    } catch (ExecutionException e) {
      e.printStackTrace();
    }
  }
}

class Task2 implements Callable<Boolean> {

  @Override
  public Boolean call() throws Exception {
    SleepUtil.sleepSeconds(10);
    return true;
  }
}
```

如果要避免 Saturation Deadlock 的方法就需要尽量提交独立的任务不相互依赖的任务。
