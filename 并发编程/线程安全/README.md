# 线程安全

线程如果都各自干活互不搭理的话自然相安无事，但多数情况下线程直接需要打交道，而且需要分享共享资源，那么这个时候最核心的就是线程安全了。当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。

- 无状态：这个有点函数式编程的味道，总之就是线程只有入参和局部变量，如果变量是引用的话，确保变量的创建和调用生命周期都发生在线程栈内，就可以确保线程安全。
- 无共享状态：完全要求线程无状态比较难实现，必要的状态是无法避免的，那么我们就必须维护不同线程之间的不同状态，这可是个麻烦事。幸好我们有 ThreadLocal 这个神器，该对象跟当前线程绑定，而且只对当前线程可见，完美解决了无共享状态的问题。
- 不可变状态：最后实在没办法避免状态共享，在线程之间共享状态，最怕的就是无法确保能维护好正确的读写顺序，而且多线程确实也无法正确维护好这个共享变量。那么我们索性粗暴点，把共享的状态定位不可变，比如价格 final 修饰一下，这样就达到安全状态共享。
- 线程同步：锁、事件等，一个线程通常也不是所有步骤都需要共享状态，而是部分环节才需要的，那么我们把共享状态的代码拆开，无共享状态的那部分自然不用关心，而共享状态的小段代码，则通过加入消息组件来传递状态。这个设计到并发模式的流水线编程模式，下文并发模式会重点介绍。

我们最早接触线程安全可能是 JDK 提供的一些号称线程安全的容器，比如 Vetor 较 ArrayList 是线程安全，HashTable 较 HashMap 是线程安全？其实线程安全类并不代表也不等同线程安全的程序，而线程不安全的类同样可以完成线程安全的程序。我们关注的也就是写出线程安全的程序，那么如何写出线程安全的代码呢，核心就是避免共享的可变状态。

synchronized 同步，该关键字确保代码块同一时间只被一个线程执行，在这个前提下再设计符合线程安全的逻辑：

- 对象：对象加锁，进入同步代码块之前获取对象锁
- 实例方法：对象加锁，执行实例方法前获取对象实例锁
- 类方法：类加锁，执行类方法前获取类锁

volatile 确保每次操作都能强制同步 CPU 缓存和主存直接的变量。而且在编译期间能阻止指令重排。读写并发情况下 volatile 也不能确保线程安全。
