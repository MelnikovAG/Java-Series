# Java 线程池

JVM 上的线程池通常应被分为以下三类：CPU-bound、Blocking IO、Non-blocking IO polling。每个类别都有不同的最佳配置和使用模式。

## CPU 绑定的线程池

对于 CPU-bound 的任务，你需要一个绑定的线程池（Bounded thread poll）；这个线程池是预先分配的，并且正好与 CPU 的数量相符合。你在这个池子里唯一能做的就是就是利用 CPU 进行的相关计算，所以超过 CPU 的数量是没有意义的，除非你碰巧有一个非常特别的工作流程，可以使用超线程（在这种情况下，你可以使用双倍的 CPU 数量）。请注意，CPU 数量加一的惯例来自于混合模式的线程池，在那里，CPU 绑定的任务和 IO 绑定的任务被合并，现在则通常不会这样做。

## 处理 Blocking IO 的线程池

固定线程池的问题是，任何阻塞的 IO 操作都会吃掉一个线程，而线程是一种极其有限的资源。因此，我们希望不惜一切代价避免在 CPU-bound 的池子里进行阻塞操作。不幸的是，这并不总是可能的（例如，当被迫使用一个阻塞的 IO 库时）。在这种情况下，你应该总是把你的阻塞操作（IO 或其他）推到一个单独的线程池：这个独立的线程池应该是缓存的，并且是没有任何预分配的大小。说白了，这是一种非常危险的线程池类型，它并不能阻止你在其他线程阻塞时分配越来越多的线程，最终可能导致系统陷入非常危险的状态。你需要确保任何导致在这个池子上运行动作的数据流是有外部约束的，这意味着你有语义上更高层次的检查，以确保在任何时间点上只有固定数量的阻塞动作可能是未完成的（这通常是通过非阻塞约束队列完成的）。

这里需要注意的是，在实现该线程池时，一般会有两种模式：对接受限队列的无界限线程池（Unbounded thread poll with bounded queue）以及自身就有界限的线程池（bounded thread pool），我们优先选择后者。有界限的线程池包含无界限的任务队列，完全不受你的控制。你无法看到有多少未完成的任务，重新安排它们，取消它们，改变你的语义，等等。当你的稀缺资源开始耗尽时，你需要能够以临时连接中断的形式将该信息传回上游，甚至更好的是，触发自动缩放以创造更多的资源。你希望在堆栈中尽可能高的层次上做到这一点，因为这给了你最大的资源管理的控制能力。

## 非阻塞轮询的线程池

最后一类有用的线程（假设你不是一个 Swing/SWT 应用程序）是异步 IO 轮询。这些线程基本上只是坐在那里询问内核是否有一个新的未完成的异步 IO 通知，并将该通知转发给应用程序的其他部分。你想用非常少的固定的、预先分配的线程来处理这个问题。许多应用程序只用一个线程来处理这个任务。这些线程应该被赋予最大的优先权，因为应用程序的延迟将围绕它们的调度而被约束。但你需要注意的是，永远不要在这个线程池上做任何工作！永远不要。永远不要。当你收到一个异步通知的时候，你应该立即转回 CPU 池。你在异步 IO 线程上花费的每一纳秒都会给你的应用程序增加延迟。由于这个原因，一些应用程序可能会发现，使他们的异步 IO 池的大小为 2 或 4 个线程，而不是传统的 1 个线程，性能会稍好一些。

## 全局线程池

我看到很多关于不要使用全局线程池的建议在流传，比如 `scala.concurrent.ExecutionContext.global`。这个建议的根源在于，全局线程池可以被任意的代码（通常是库代码）访问，而且你无法（很容易）确保这些代码适当地使用线程池。这对你来说有多大的影响，很大程度上取决于你的 classpath。全局线程池是非常方便的，但同样地，拥有你自己的应用程序内部的全局池也并不难。

在这一点上，对于任何框架或库，如果 a）使配置线程池变得困难，或者 b）直接默认为一个你无法控制的线程池，都要非常谨慎地看待。无论如何，你几乎总是会在你的应用程序中的某个地方有某种单子对象，它有这三个池子，预先配置好供使用。如果你赞成 "隐式 ExecutionContext 模式"，那么你应该让 CPU 池成为隐式的，而其他的必须明确选择。

## Loom
