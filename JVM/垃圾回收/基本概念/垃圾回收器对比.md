# 垃圾回收器对比

# 垃圾回收器分类

当我们在讨论垃圾回收器时，往往也会涉及到很多的概念；譬如并行（Parallel）与并发（Concurrent）、Minor GC 与 Major/Full GC。

- 并行指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；并发指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，用户程序在继续运行，而垃圾收集程序运行于另一个 CPU 上。

- Minor GC 指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快；Major GC 指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC(但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程)，Major GC 的速度一般会比 Minor GC 慢 10 倍以上。

从不同角度分析垃圾回收器，可以将其分为不同的类型：

- 线程数：分为串行垃圾回收器和并行垃圾回收器。

  - 串行垃圾回收器一次只使用一个线程进行垃圾回收；
  - 并行垃圾回收器一次将开启多个线程同时进行垃圾回收。在并行能力较强的 CPU 上，使用并行垃圾回收器可以缩短 GC 的停顿时间；

- 工作模式：分为并发式垃圾回收器和独占式垃圾回收器。

  - 并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间；
  - 独占式垃圾回收器 (Stop the world) 一旦运行，就停止应用程序中的其他所有线程，直到垃圾回收过程完全结束；

- 碎片处理方式：分为压缩式垃圾回收器和非压缩式垃圾回收器。

  - 压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片；
  - 非压缩式的垃圾回收器不进行这步操作；

- 工作的内存区间：新生代垃圾回收器和老年代垃圾回收器。

# 垃圾回收器的衡量指标

我们最常用的评价垃圾回收器的指标就是吞吐量与停顿时间：

- 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；

- 高吞吐量则可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务；

具体的指标列举如下：

- 吞吐量：指在应用程序的生命周期内，应用程序所花费的时间和系统总运行时间的比值。系统总运行时间=应用程序耗时+GC 耗时。如果系统运行了 100min，GC 耗时 1min，那么系统的吞吐量就是 (100-1)/100=99%；

- 垃圾回收器负载：和吞吐量相反，垃圾回收器负载指来记回收器耗时与系统运行总时间的比值；

- 停顿时间：指垃圾回收器正在运行时，应用程序的暂停时间。对于独占回收器而言，停顿时间可能会比较长。使用并发的回收器时，由于垃圾回收器和应用程序交替运行，程序的停顿时间会变短，但是，由于其效率很可能不如独占垃圾回收器，故系统的吞吐量可能会较低；

- 垃圾回收频率：指垃圾回收器多长时间会运行一次。一般来说，对于固定的应用而言，垃圾回收器的频率应该是越低越好。通常增大堆空间可以有效降低垃圾回收发生的频率，但是可能会增加回收产生的停顿时间；

- 反应时间：指当一个对象被称为垃圾后多长时间内，它所占据的内存空间会被释放；

- 堆分配：不同的垃圾回收器对堆内存的分配方式可能是不同的。一个良好的垃圾回收器应该有一个合理的堆内存区间划分；

在对象查找算法的帮助下我们可以找到内存可以被使用的，或者说那些内存是可以回收，更多的时候我们肯定愿意做更少的事情达到同样的目的。

# ZGC

与标记对象的传统算法相比，ZGC 在指针上做标记，在访问指针时加入 Load Barrier（读屏障），比如当对象正被 GC 移动，指针上的颜色就会不对，这个屏障就会先把指针更新为有效地址再返回，也就是，永远只有单个对象读取时有概率被减速，而不存在为了保持应用与 GC 一致而粗暴整体的 Stop The World。
